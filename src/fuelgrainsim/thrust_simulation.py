"""
Main file
Performs thrust curve calculations and plotting
"""

from .thrust_curve_class import Shape, Plot, SVG
import math
import pandas as pd
import matplotlib.pyplot as plt
import subprocess
import time
from pathlib import Path
import argparse
import shutil
import multiprocessing as mp
import os
import logging

class Config:
    """
    Stores global variables
    """
    p = math.pi  #pi
    m_fu = 1.40300287488  #Required mass of fuel  (kg)
    g = 9.8 #Gravitational constant
    m_fu_adj = 1.2 * m_fu  #Required fuel grain mass with 20 percent margin
    t_0 = 0

import logging

def get_area(polygon):
    """
    Returns the area of a given polygon.

    Parameters:
        polygon (shapely.geometry.Polygon): The polygon whose area is to be calculated.

    Returns:
        float: The area of the polygon in square units.
    """
    return polygon.area


def get_length(polygon):
    """
    Returns the perimeter (length) of a given polygon.

    Parameters:
        polygon (shapely.geometry.Polygon): The polygon whose perimeter is to be calculated.

    Returns:
        float: The perimeter of the polygon in linear units.
    """
    return polygon.length


def regression(shape,variables):
    """
    Calculates the regression rate based on the intersected polygon's area.

    Parameters:
        shape (Shape): The shape object that holds the polygon to compute the regression on.

    Returns:
        float: The regression rate in meters per second.
    """
    a = variables[1]
    nn = variables[2]
    m_dot_ox = variables[4]

    x=shape.intersect.area/1000000
    return a * math.pow((m_dot_ox / x), nn)


def thrust(area,variables):
    """
    Calculates the thrust generated by burning a given volume of fuel.

    Parameters:
        area (float): The change in the fuel grain area over a given time step in square meters.

    Returns:
        float: The thrust generated by the fuel grain in Newtons (N).
        """
    isp = variables[0]
    rho = variables[3]
    m_dot_ox = variables[4]
    l = variables[5]
    step_num = variables[6]
    dt = 1 / step_num

    m_dot_total = m_dot_ox + (area * l * rho / dt)
    thr1 = m_dot_total * isp * Config.g
    return thr1


def write_csv(data_frame,destination):
    """
    Writes the provided DataFrame to a CSV file.

    Parameters:
        data_frame (pandas.DataFrame): The DataFrame containing the simulation data to be written to a CSV file.

    Returns:
        None
    """
    data_frame.to_csv(destination)


def dxf_to_svg(dxf: str,svg: str):
    """
    Converts a DXF file to an SVG file using Inkscape.

    Parameters:
        dxf (str): Path to the DXF file that needs to be converted.
        svg (str): The output path where the SVG file will be saved.

    Raises:
        RunTimeError: If inkscape is not installed.
        FileNotFoundError: If the provided DXF file does not exist.
        TimeoutError: If conversion takes too long to complete.

    Returns:
        None
    """
    dxf_path = Path(dxf)
    svg_path = Path(svg)
    logging.info(f"Converting {dxf_path} to {svg_path}")

    if dxf_path.exists():
        cmd = ["start","inkscape",str(dxf_path),"--export-type=svg","--export-filename="+str(svg_path)]
        subprocess.Popen(cmd,shell=True)
    else:
        logging.error(f"DXF file not found: {dxf}")
        raise FileNotFoundError("File not found")

    timeout = 10
    start_time = time.time()
    while not Path(svg).exists():
        if time.time() - start_time > timeout:
            logging.error(f"SVG conversion timeout: {svg} was not created in {timeout} seconds")
            raise TimeoutError(f"SVG conversion timed out after {timeout} seconds")
    logging.info(f"Conversion Complete")


def file_args():
    """
    Parses command-line arguments to get the input and output folder paths.

    Returns:
        tuple: A tuple containing the input folder path and the output folder path as strings.
    """
    parser = argparse.ArgumentParser(description='Import folder and export folder')
    parser.add_argument('-i', '--input', type=str, help='Provide a folder containing DXF files', required=True)
    parser.add_argument('-o', '--output', type=str, help='Provide a folder for simulation results', required=True)
    parser.add_argument('-l', '--log_level', type=str, help="Enter logging level to be displayed", default="ERROR")
    parser.add_argument('--isp', type=float, help='Initial specific impulse', required=True)
    parser.add_argument('--a', type=float, help='Enter regression coefficient a', required=True)
    parser.add_argument('--nn', type=float, help='Enter regression coefficient nn', required=True)
    parser.add_argument('--density', type=float, help="Enter material density", required = True)
    parser.add_argument('--flow', type=float, help='Oxidiser flow rate', required=True)
    parser.add_argument('--length', type=float, help='Fuel grain length', required=True)
    parser.add_argument('--iterations', type=float, help='Number of iteration', required=True)
    parser.add_argument('--time', type=float, help="Fire time", required=True)

    args = parser.parse_args()
    logging.info(f"Input folder: {args.input_folder}, Output folder: {args.output_folder}")
    arg_list = [args.input, args.output, args.log_level, args.isp, args.a, args.nn, args.density, args.flow, args.length, args.iterations, args.time]
    return arg_list


def curve_sim(shape,variables):
    """
    Runs the thrust simulation on the given shape object.

    Parameters:
        shape (Shape): The shape object to simulate.

    Returns:
        tuple: A tuple containing:
            - data_list (list): A list of sub-lists with simulation results (time, thrust, regression, area, perimeter).
            - poly_lst (list): A list of polygons generated during the simulation.
    """
    time_lst, thr_lst, r_dot_lst, poly_lst, area_lst, per_lst = [0], [0], [0], [shape.intersect], [0], [shape.length()]
    t_0 = time_lst[0]

    steps_num = variables[6]
    delta_t = 1 / steps_num
    fire_times = variables[7]
    s = math.floor(fire_times / delta_t)


    for each in range(s):
        t_0 += delta_t
        time_lst.append(t_0)
        a_1 = shape.intersect.area
        r_dot = regression(shape,variables)
        r_dot_lst.append(r_dot)
        offset = r_dot * delta_t * 1000
        shape.buffer(offset=offset)
        poly_lst.append(shape.intersect)
        a_2 = shape.intersect.area
        delta_a = abs(a_2 - a_1)
        area_lst.append(delta_a)
        thr = thrust(delta_a / 1000000,variables)
        thr_lst.append(thr)
        per_lst.append(shape.wetted_length())
    poly_lst.append(shape.boundary)
    data_list = [time_lst, r_dot_lst, per_lst, thr_lst,area_lst]
    logging.info(f"Simulation complete")
    return data_list, poly_lst


def create_df(data_list):
    """
    Creates a Pandas DataFrame from the simulation data list and cleans the data frame.

    Parameters:
        data_list (list): A list of sub-lists containing the simulation data for time, thrust, regression, area, and perimeter.

    Returns:
        pandas.DataFrame: The cleaned DataFrame with simulation data, indexed by time.
    """
    df = pd.DataFrame({"Thrust": data_list[3], "Regression": data_list[1], "Delta Area": data_list[4],"Perimeter": data_list[2]})
    df.index = data_list[0]
    df = df.reset_index()
    df['index'] = df['index'].round(2)
    df = df.set_index('index')
    logging.info(f"Created and processed dataframe")
    return df


def create_folder(name: str,folder: Path):
    """
    Creates a sub-folder inside the given parent folder if it doesn't exist.

    Parameters:
        name (str): Name of the sub-folder to create.
        folder (Path): Path to the parent folder.

    Returns:
        Path: Path to the created (or existing) sub-folder.
    """
    sub_folder = folder / name
    sub_folder.mkdir(parents=True, exist_ok=True)
    logging.info(f"Created folder: {sub_folder}")
    return sub_folder


def move_file(source: Path,destination_folder: Path):
    """
    Copies a file from the source path to a destination folder.

    Parameters:
        source (Path): Path of the file to be copied.
        destination_folder (Path): Folder where the file should be copied.

    Returns:
        Path: Path to the copied file in the destination folder.
    """
    destination = destination_folder / source.name
    shutil.copy(str(source), str(destination))
    logging.info(f"Moved file: {source} -> {destination}")
    return destination


def generate(file,variables):
    """
    Runs the thrust simulation for a given shape extracted from an SVG file.

    Parameters:
        file (Path): Path to the SVG file.

    Returns:
        tuple: A tuple containing:
            - data_list (list): List of simulation results (time, thrust, regression, etc.).
            - poly_lst (list): List of polygons generated during the simulation.
    """
    paths = SVG(file)
    scaled_inner = paths.get_inner()
    shape = Shape(scaled_inner)
    data, poly_lst = curve_sim(shape,variables)
    logging.info(f"Generated shape from SVG file: {file}")
    return data, poly_lst


def create_chart(file_name: Path,plot_object):
    """
    Generates and saves a thrust simulation chart.

    Parameters:
        file_name (Path): Path where the chart image should be saved.
        plot_object (Plot): Plot object containing the simulation data.

    Returns:
        None
    """
    plot = plot_object
    img_file = file_name
    p_layout = [['A panel', 'A panel', 'B panel', 'C edge'],
                ['A panel', 'A panel', 'B panel', 'C edge']]
    fig, axes = plt.subplot_mosaic(p_layout, figsize=(9, 4))

    plot.plot_polygons(color="magma", color_2="plasma", ax=axes["A panel"], fig=fig)
    plot.plot_data("Thrust", title="Thrust", ax=axes["B panel"], x_label="Time (s)", y_label="Thrust (N)", fig=fig)
    plot.plot_data("Regression", title="Regression", ax=axes["C edge"], x_label="Time (s)", y_label="Regression (m/s)",fig=fig)
    plt.tight_layout()
    fig.savefig(img_file, bbox_inches="tight")
    plt.close(fig)
    logging.info(f"Created and saved chart image: {img_file}")


def run(each,folder,variables):
    """
    Runs the thrust simulation for a given DXF file. It processes the DXF file by converting it to SVG, simulating the thrust curve,
    and saving the results (CSV, PNG, and animation) to an output folder.

    Parameters:
        each (Path): The Path object representing the DXF file to process.
        folder (Path): The Path object representing the output folder where the results will be saved.

    Returns:
        None
    """
    sub_folder = create_folder(each.stem,folder)
    dxf_final = move_file(each,sub_folder)
    svg_des = sub_folder / each.with_suffix(".svg")
    dxf_to_svg(str(dxf_final), str(svg_des))
    data, poly_lst = generate(svg_des,variables)
    df = create_df(data)
    csv_file = sub_folder / f"{each.stem}.csv"
    write_csv(df,csv_file)
    img_file = sub_folder / f"{each.stem}.png"
    plot = Plot(poly_lst, df)
    create_chart(img_file,plot)
    plot.animate(each.stem, sub_folder, save=True)
    logging.info(f"Processed {each.name}")


def run_simulation(input_folder: str, output_folder: str, isp: str, a: str, nn: str, density: str, flow: str, length: str, iterations: str, time: str, log_level: str = "ERROR"):
    """
    Runs the thrust curve simulation programmatically.

    Parameters:
        input_folder (str): Path to the input folder containing DXF files.
        output_folder (str): Path to the output folder for results.
        variables (str): Comma-separated string of simulation parameters.
        log_level (str): Logging level (default is "ERROR").

    Returns:
        None
    """
    dxf = Path(input_folder)
    if not dxf.exists():
        raise FileNotFoundError(f"Input folder not found: {input_folder}")

    folder = Path(output_folder)
    folder.mkdir(exist_ok=True)

    log_level = getattr(logging, log_level.upper())
    logging.basicConfig(
        format="%(asctime)s - %(levelname)s - %(funcName)s - %(message)s",
        level=log_level
    )

    files = list(dxf.glob("*.dxf"))
    variable_list = [float(isp),float(a),float(nn),float(density),float(flow),float(length),float(iterations),float(time)]

    with mp.Pool(processes=4) as pool:
        pool.starmap(run, [(each, folder, variable_list) for each in files])

    logging.info("Simulation completed successfully.")
    print("Simulation DONE")
    return True


def main():
    dxf, svg, level, variables = file_args()
    run_simulation(dxf, svg, variables, level)

if __name__ == "__main__":
    main()


